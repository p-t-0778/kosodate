<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kanji GO-like (Fixed UI + Timeout Choice)</title>
  <style>
    :root{
      --bg:#0f0f12;
      --panel:#222228;
      --panel2:#2b2b33;
      --card:#3b3b46;
      --text:#fff;
      --muted: rgba(255,255,255,.78);
      --muted2: rgba(255,255,255,.55);

      --lv1:#5ecbff;
      --lv2:#7bff91;
      --lv3:#ffd36b;
      --lv4:#ff6b6b;
      --lvD:#c9c9d2;

      --danger:#ff6b6b;
      --ok:#7bff91;
    }

    html, body { margin:0; height:100%; background:var(--bg); color:var(--text); }
    .wrap{
      height:100%;
      display:grid;
      grid-template-rows: 1fr auto;
      min-height: 100svh;
    }

    /* Canvasは「問題表示エリア」として使う */
    .stage{
      position:relative;
      min-height: 0;
    }
    canvas {
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }

    /* 下部UI */
    .ui{
      background:var(--panel);
      border-top: 1px solid rgba(255,255,255,.06);
      padding:12px;
      display:grid;
      gap:10px;
    }

    /* 上段：情報バー */
    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:space-between;
    }

    .stats{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .badge{
      display:inline-flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color: var(--muted);
    }

    .pill{
      display:inline-flex;
      align-items:center;
      padding:2px 10px;
      height:22px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color:#fff;
      white-space:nowrap;
    }

    .progress{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }
    .dot{
      width:14px;
      height:14px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      position:relative;
    }
    .dot.done::after{
      content:"";
      position:absolute;
      inset:2px;
      border-radius:3px;
      background: rgba(255,255,255,.85);
      opacity:.75;
    }
    .dot.lv1{ background: color-mix(in srgb, var(--lv1) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv1) 40%, rgba(255,255,255,.18)); }
    .dot.lv2{ background: color-mix(in srgb, var(--lv2) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv2) 40%, rgba(255,255,255,.18)); }
    .dot.lv3{ background: color-mix(in srgb, var(--lv3) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv3) 40%, rgba(255,255,255,.18)); }
    .dot.lv4{ background: color-mix(in srgb, var(--lv4) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv4) 40%, rgba(255,255,255,.18)); }

    /* 中段：入力 + 操作 */
    .midbar{
      display:grid;
      grid-template-columns: auto 1fr auto;
      gap:10px;
      align-items:center;
    }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      height:42px;
      padding:0 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      cursor:pointer;
      background:#3a3a44;
      color:#fff;
      font-size:14px;
    }
    button:hover{ filter:brightness(1.08); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    input{
      height:42px;
      border-radius:12px;
      border:none;
      outline:none;
      padding:0 12px;
      font-size:18px;
      width:100%;
      background: #ffffff;
      color:#111;
    }
    @media (max-width: 520px){
      input{ font-size:16px; }
    }

    .label{
      font-size:13px;
      color: var(--muted2);
      white-space:nowrap;
    }

    /* 下段：メッセージ＆選択UI */
    .bottombar{
      display:grid;
      gap:8px;
      background: var(--panel2);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:10px 12px;
    }

    .status{
      font-size:13px;
      color: var(--muted);
      line-height: 1.4;
    }
    .status strong{ color:#fff; }

    .choice{
      display:none;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .answer{
      display:none;
      color: rgba(255,255,255,.9);
    }

    /* 入力ミス演出（ミス扱いではない） */
    .shake { animation: shake .18s linear 0s 1; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-4px); }
      50%{ transform: translateX(4px); }
      75%{ transform: translateX(-3px); }
      100%{ transform: translateX(0); }
    }
    .wrong{ box-shadow: 0 0 0 2px rgba(255,107,107,.45); }

    /* スマホは縦積み */
    @media (max-width: 900px){
      .midbar{ grid-template-columns: 1fr; }
      .label{ white-space:normal; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="stage">
    <canvas id="c"></canvas>
  </div>

  <div class="ui">
    <div class="topbar">
      <div class="stats">
        <div class="badge">LV: <span class="pill" id="lvPill">-</span></div>
        <div class="badge">TIME: <span class="pill" id="timePill">10.0s</span></div>
        <div class="badge">LIFE: <span class="pill" id="lifePill">5</span></div>
        <div class="badge">正解: <span class="pill" id="clearsPill">0/10</span></div>
      </div>

      <div class="progress" title="進捗">
        <span class="label">進捗</span>
        <div id="prog" class="progress"></div>
      </div>
    </div>

    <div class="midbar">
      <div class="controls">
        <button id="start">スタート</button>
        <button id="restart">リスタート</button>
      </div>

      <div style="display:grid; gap:6px;">
        <div class="label">ひらがなで入力してEnter（入力ミスはOK / 時間切れだけ選択）</div>
        <input id="inp"
               autocomplete="off"
               autocapitalize="off"
               spellcheck="false"
               inputmode="kana"
               placeholder="例：とうきょう"
               disabled />
      </div>

      <div class="controls" style="justify-content:flex-end;">
        <button id="focusBtn" title="入力欄にフォーカス">入力</button>
      </div>
    </div>

    <div class="bottombar">
      <div class="status" id="status">読み込み中…（questions.csv）</div>

      <div class="choice" id="choiceWrap">
        <span class="label">時間切れ：</span>
        <button id="retrySame">同じ問題</button>
        <button id="skipDiff">別の問題</button>
        <span class="answer" id="showAnswer"></span>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== 設定 =====
  const CSV_PATH = "./questions.csv";
  const TIME_LIMIT = 10.0;
  const TOTAL_CLEAR = 10;
  const LIFE_START = 5;

  // Lv固定内訳：1〜3が3問ずつ、4が1問
  const NEED = {1:3,2:3,3:3,4:1};

  // Canvas上のカード表示位置（固定）
  const FIXED_Y_RATIO = 0.30; // 画面の上寄り
  const MIN_FIXED_Y = 110;

  const LV_COLOR = {
    1: getComputedStyle(document.documentElement).getPropertyValue('--lv1').trim(),
    2: getComputedStyle(document.documentElement).getPropertyValue('--lv2').trim(),
    3: getComputedStyle(document.documentElement).getPropertyValue('--lv3').trim(),
    4: getComputedStyle(document.documentElement).getPropertyValue('--lv4').trim(),
    default: getComputedStyle(document.documentElement).getPropertyValue('--lvD').trim()
  };

  // ===== Canvas =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);

  // ===== UI =====
  const startBtn = document.getElementById("start");
  const restartBtn = document.getElementById("restart");
  const focusBtn = document.getElementById("focusBtn");
  const inp = document.getElementById("inp");

  const uiStatus = document.getElementById("status");
  const uiLvPill = document.getElementById("lvPill");
  const uiTimePill = document.getElementById("timePill");
  const uiLifePill = document.getElementById("lifePill");
  const uiClearsPill = document.getElementById("clearsPill");
  const progEl = document.getElementById("prog");

  const choiceWrap = document.getElementById("choiceWrap");
  const retrySameBtn = document.getElementById("retrySame");
  const skipDiffBtn = document.getElementById("skipDiff");
  const showAnswer = document.getElementById("showAnswer");

  // ===== 進捗（固定10マス）=====
  const progressDots = [];
  function buildProgressFixed() {
    progEl.innerHTML = "";
    progressDots.length = 0;

    const seq = [
      ...Array(3).fill(1),
      ...Array(3).fill(2),
      ...Array(3).fill(3),
      4
    ];

    for (let i = 0; i < seq.length; i++) {
      const lv = seq[i];
      const d = document.createElement("div");
      d.className = `dot lv${lv}`;
      d.title = `Q${i+1} (Lv${lv})`;
      progEl.appendChild(d);
      progressDots.push(d);
    }
    markProgressDone(0);
  }

  function markProgressDone(nDone) {
    for (let i = 0; i < progressDots.length; i++) {
      progressDots[i].classList.toggle("done", i < nDone);
    }
  }

  // ===== 音 =====
  let audioCtx = null;
  function beep({freq=880, dur=0.07, type="triangle", vol=0.05} = {}) {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = vol;

      o.connect(g);
      g.connect(audioCtx.destination);

      const t = audioCtx.currentTime;
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      o.start(t);
      o.stop(t + dur);
    } catch (_) {}
  }

  // ===== CSV読み込み =====
  function parseCSV(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith("#"));
    if (!lines.length) return [];

    const header = lines[0].split(",").map(s => s.trim());
    const idx = (name) => header.indexOf(name);

    const iLevel = idx("level");
    const iKanji = idx("kanji");
    const iReading = idx("reading");
    if (iLevel < 0 || iKanji < 0 || iReading < 0) {
      throw new Error("CSVヘッダは level,kanji,reading が必要です");
    }

    const rows = [];
    for (let i=1; i<lines.length; i++) {
      const cols = lines[i].split(",").map(s => s.trim());
      const level = Number(cols[iLevel]);
      const kanji = cols[iKanji];
      const reading = cols[iReading];
      if (!level || !kanji || !reading) continue;
      rows.push({ level, kanji, reading });
    }
    return rows;
  }

  async function loadQuestions() {
    const res = await fetch(CSV_PATH, { cache: "no-store" });
    if (!res.ok) throw new Error(`CSV読み込み失敗: ${res.status}`);
    return parseCSV(await res.text());
  }

  // ===== 状態 =====
  let QUESTIONS = [];
  let remaining = {1:[],2:[],3:[],4:[]};
  let curLevel = 1;

  const state = {
    mode: "loading", // loading | ready | playing | gameover | clear
    current: null,
    startTime: 0,
    life: LIFE_START,
    clears: 0,
    waitingChoice: false, // 時間切れ選択中
  };

  // 演出
  let flashAlpha = 0;
  let flashColor = "#ffffff";
  let maruAlpha = 0;

  function triggerCorrectFX(lv) {
    flashAlpha = 0.55;
    flashColor = LV_COLOR[lv] || "#ffffff";
    maruAlpha = 1.0;
  }

  function normalize(s){ return (s || "").trim(); }

  function shuffleInPlace(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function validateAndBuildPools() {
    const byLv = new Map([[1,[]],[2,[]],[3,[]],[4,[]]]);
    for (const q of QUESTIONS) {
      if (byLv.has(q.level)) byLv.get(q.level).push(q);
    }

    const missing = [];
    for (const lv of [1,2,3,4]) {
      if (byLv.get(lv).length < NEED[lv]) {
        missing.push(`Lv${lv}が${NEED[lv]}問必要（今${byLv.get(lv).length}問）`);
      }
    }
    if (missing.length) throw new Error("CSVの問題数が足りません: " + missing.join(" / "));

    const pick = {};
    for (const lv of [1,2,3,4]) {
      const arr = byLv.get(lv).slice();
      shuffleInPlace(arr);
      pick[lv] = arr.slice(0, NEED[lv]);
    }

    remaining = {
      1: pick[1].slice(),
      2: pick[2].slice(),
      3: pick[3].slice(),
      4: pick[4].slice()
    };
    curLevel = 1;

    buildProgressFixed();
  }

  function setLvPill(lv) {
    if (!lv) {
      uiLvPill.textContent = "-";
      uiLvPill.style.borderColor = "rgba(255,255,255,.15)";
      uiLvPill.style.background = "rgba(255,255,255,.06)";
      uiLvPill.style.color = "#fff";
      return;
    }
    const c = LV_COLOR[lv] || LV_COLOR.default;
    uiLvPill.textContent = `Lv${lv}`;
    uiLvPill.style.borderColor = c + "55";
    uiLvPill.style.background = c + "22";
    uiLvPill.style.color = c;
  }

  function hideChoice() {
    state.waitingChoice = false;
    choiceWrap.style.display = "none";
    showAnswer.style.display = "none";
    showAnswer.textContent = "";
  }

  function updatePills(remainSec) {
    uiTimePill.textContent = `${remainSec.toFixed(1)}s`;
    uiLifePill.textContent = `${state.life}`;
    uiClearsPill.textContent = `${state.clears}/${TOTAL_CLEAR}`;
  }

  function setMode(m) {
    state.mode = m;

    if (m === "ready") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "スタート";
      setLvPill(null);
      hideChoice();
      updatePills(TIME_LIMIT);
      uiStatus.innerHTML = "<strong>スタート</strong>を押して開始。入力ミスはOK、<strong>時間切れだけ</strong>選択が出る。";
    }

    if (m === "playing") {
      inp.disabled = false;
      startBtn.disabled = true;
      hideChoice();
      inp.focus();
    }

    if (m === "clear") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "もう一回";
      hideChoice();
      updatePills(TIME_LIMIT);
      uiStatus.innerHTML = "<strong>CLEAR!</strong> 10問正解。おつかれ！";
    }

    if (m === "gameover") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "もう一回";
      hideChoice();
      updatePills(TIME_LIMIT);
      uiStatus.innerHTML = "<strong>GAME OVER</strong>…「もう一回」or リスタート";
    }
  }

  function resetGame() {
    state.life = LIFE_START;
    state.clears = 0;
    state.current = null;
    hideChoice();

    inp.value = "";
    inp.classList.remove("wrong","shake");
    markProgressDone(0);

    validateAndBuildPools();
    setMode("ready");
  }

  function advanceLevelIfNeeded() {
    while (curLevel <= 4 && remaining[curLevel].length === 0) curLevel += 1;
  }

  function pickFromCurrentLevel({excludeSame=false} = {}) {
    const arr = remaining[curLevel];
    if (!arr.length) return null;

    if (!excludeSame || arr.length === 1 || !state.current) {
      const idx = Math.floor(Math.random() * arr.length);
      return { q: arr[idx], idx };
    }

    const candidates = [];
    for (let i = 0; i < arr.length; i++) {
      const it = arr[i];
      if (it.kanji !== state.current.kanji || it.reading !== state.current.reading) {
        candidates.push({q: it, idx: i});
      }
    }
    if (!candidates.length) {
      const idx = Math.floor(Math.random() * arr.length);
      return { q: arr[idx], idx };
    }
    return candidates[Math.floor(Math.random() * candidates.length)];
  }

  function spawnNext({excludeSame=false} = {}) {
    if (state.clears >= TOTAL_CLEAR) {
      setMode("clear");
      return;
    }

    advanceLevelIfNeeded();
    if (curLevel > 4) {
      setMode("clear");
      return;
    }

    const picked = pickFromCurrentLevel({excludeSame});
    if (!picked) {
      setMode("clear");
      return;
    }

    const { q, idx } = picked;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    const fixedY = Math.max(MIN_FIXED_Y, H * FIXED_Y_RATIO);

    state.current = {
      level: q.level,
      kanji: q.kanji,
      reading: q.reading,
      x: W / 2,
      y: fixedY,
      timeLimit: TIME_LIMIT,
      _idxInRemaining: idx
    };

    state.startTime = performance.now();
    setLvPill(q.level);
    hideChoice();

    uiStatus.innerHTML = `Lv<strong>${q.level}</strong>：ひらがなでEnter（時間切れだけ選択）`;
    updatePills(TIME_LIMIT);
  }

  function startOrReplay() {
    if (state.mode === "ready") {
      setMode("playing");
      spawnNext();
      beep({freq: 660, dur: 0.05, type: "sine", vol: 0.03});
      return;
    }
    if (state.mode === "clear" || state.mode === "gameover") {
      resetGame();
      setMode("playing");
      spawnNext();
      beep({freq: 660, dur: 0.05, type: "sine", vol: 0.03});
    }
  }

  function correct() {
    if (state.current && typeof state.current._idxInRemaining === "number") {
      remaining[curLevel].splice(state.current._idxInRemaining, 1);
    }

    state.clears += 1;
    markProgressDone(state.clears);

    triggerCorrectFX(state.current?.level);
    beep({freq: 880, dur: 0.07, type: "triangle", vol: 0.05});

    if (state.clears >= TOTAL_CLEAR) {
      setMode("clear");
      return;
    }
    spawnNext();
  }

  function wrongInputFX() {
    inp.classList.add("wrong","shake");
    if (navigator.vibrate) navigator.vibrate(12);
    setTimeout(() => inp.classList.remove("shake"), 220);
    setTimeout(() => inp.classList.remove("wrong"), 420);
    beep({freq: 300, dur: 0.04, type: "sine", vol: 0.03});
    // ステータスは下部パネル内だけ更新（Canvas上に文字を増やさない）
    uiStatus.innerHTML = "入力はOK。<strong>時間内なら何度でも</strong>試せる。";
  }

  function showTimeoutChoice() {
    state.waitingChoice = true;
    choiceWrap.style.display = "flex";
    showAnswer.style.display = "none";
    showAnswer.textContent = "";
    uiStatus.innerHTML = "<strong>時間切れ！</strong> 同じ問題を続けるか、別の問題へ（答え表示）";
  }

  function timeoutMiss() {
    state.life -= 1;

    beep({freq: 180, dur: 0.10, type: "sawtooth", vol: 0.04});
    if (navigator.vibrate) navigator.vibrate(40);

    if (state.life <= 0) {
      setMode("gameover");
      return;
    }

    showTimeoutChoice();
  }

  // ===== 選択（時間切れのみ）=====
  retrySameBtn.addEventListener("click", () => {
    if (state.mode !== "playing" || !state.current) return;
    state.startTime = performance.now();
    hideChoice();
    inp.focus();
  });

  skipDiffBtn.addEventListener("click", () => {
    if (state.mode !== "playing" || !state.current) return;

    showAnswer.style.display = "inline";
    showAnswer.textContent = `答え：${state.current.reading}`;

    setTimeout(() => {
      hideChoice();
      // 同Lv内の別問題を優先（可能なら現在以外）
      spawnNext({excludeSame:true});
      inp.focus();
    }, 900);
  });

  // 入力フォーカス
  focusBtn.addEventListener("click", () => inp.focus());

  // ===== 入力（ミスは選択を出さない）=====
  inp.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    e.preventDefault();

    if (state.mode !== "playing" || !state.current) return;
    if (state.waitingChoice) return;

    const typed = normalize(inp.value);
    inp.value = "";
    if (!typed) return;

    if (typed === state.current.reading) {
      correct();
    } else {
      wrongInputFX(); // ミス扱いしない（選択なし）
    }
  });

  // ===== 描画 =====
  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function drawOverlay(main, sub) {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.fillStyle = "rgba(0,0,0,.62)";
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "#fff";
    ctx.font = "bold 34px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText(main, W/2, H/2 - 16);

    if (sub) {
      ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillText(sub, W/2, H/2 + 20);
    }

    ctx.textAlign = "left";
  }

  function drawMaru() {
    if (maruAlpha <= 0) return;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.save();
    ctx.globalAlpha = maruAlpha;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(W/2, H*0.38, Math.min(W,H) * 0.09, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    maruAlpha *= 0.82;
    if (maruAlpha < 0.01) maruAlpha = 0;
  }

  function draw() {
    const now = performance.now();
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = "#0f0f12";
    ctx.fillRect(0, 0, W, H);

    // フラッシュ
    if (flashAlpha > 0.001) {
      ctx.globalAlpha = flashAlpha;
      ctx.fillStyle = flashColor;
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;
      flashAlpha *= 0.88;
    } else {
      flashAlpha = 0;
    }

    if (state.mode === "ready") {
      drawOverlay("スタートを押して開始", "入力ミスはOK / 時間切れだけ選択");
      return;
    }
    if (state.mode === "gameover") {
      drawOverlay("GAME OVER", "「もう一回」or リスタート");
      return;
    }
    if (state.mode === "clear") {
      drawOverlay("CLEAR!", "10問正解。おつかれ！");
      return;
    }

    if (state.mode === "playing" && state.current) {
      let remain = 0;
      if (!state.waitingChoice) {
        const elapsed = (now - state.startTime) / 1000;
        remain = Math.max(0, state.current.timeLimit - elapsed);
      }
      updatePills(remain);

      if (!state.waitingChoice && remain <= 0) {
        timeoutMiss();
        return;
      }

      // 固定位置（毎フレーム補正）
      const fixedY = Math.max(MIN_FIXED_Y, H * FIXED_Y_RATIO);
      state.current.x = W / 2;
      state.current.y = fixedY;

      const lv = state.current.level;
      const accent = LV_COLOR[lv] || LV_COLOR.default;

      const text = state.current.kanji;
      ctx.font = "36px system-ui, -apple-system, Segoe UI, sans-serif";
      const tw = ctx.measureText(text).width;
      const boxW = Math.min(W - 40, tw + 44);
      const boxH = 64;
      const x = (W - boxW) / 2;
      const y = state.current.y;

      // 影
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      roundRect(x, y + 4, boxW, boxH, 14);
      ctx.fill();
      ctx.globalAlpha = 1;

      // 本体
      ctx.fillStyle = "#3b3b46";
      roundRect(x, y, boxW, boxH, 14);
      ctx.fill();

      // アクセントバー
      ctx.fillStyle = accent + "cc";
      ctx.fillRect(x, y, boxW, 4);

      // 文字（中央寄せ）
      ctx.fillStyle = "#fff";
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      ctx.fillText(text, W/2, y + boxH/2);
      ctx.textAlign = "left";

      // タイムバー
      const barW = boxW;
      const barX = x;
      const barY = y + boxH + 12;
      ctx.fillStyle = "#555";
      ctx.fillRect(barX, barY, barW, 8);
      ctx.fillStyle = accent;
      ctx.fillRect(barX, barY, barW * (remain / state.current.timeLimit), 8);

      drawMaru();
    }
  }

  function loop() {
    draw();
    requestAnimationFrame(loop);
  }

  // ===== 起動 =====
  (async () => {
    resize();
    try {
      uiStatus.textContent = "questions.csv を読み込み中…";
      QUESTIONS = await loadQuestions();
      if (!QUESTIONS.length) throw new Error("CSVに問題がありません");

      QUESTIONS = QUESTIONS.filter(q => [1,2,3,4].includes(q.level));
      validateAndBuildPools();

      state.life = LIFE_START;
      state.clears = 0;
      set
