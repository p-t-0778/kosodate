<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kanji GO-like (Fixed + Choice + LevelGate)</title>
  <style>
    :root{
      --bg:#0f0f12;
      --panel:#222228;
      --text:#fff;
      --muted2: rgba(255,255,255,.55);

      --lv1:#5ecbff;
      --lv2:#7bff91;
      --lv3:#ffd36b;
      --lv4:#ff6b6b;
      --lvD:#c9c9d2;
    }

    html, body { margin:0; height:100%; background:var(--bg); color:var(--text); }
    .wrap { height:100%; display:grid; grid-template-rows: 1fr auto; }
    canvas { width:100%; height:100%; display:block; touch-action:none; }

    .ui{
      background:var(--panel);
      padding:10px 12px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:12px;
      align-items:center;
    }

    .left{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      min-width:0;
    }

    .label{ font-size:14px; opacity:.9; white-space:nowrap; }
    .hint{ font-size:12px; color:var(--muted2); }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      height:40px;
      padding:0 12px;
      border-radius:10px;
      border:none;
      cursor:pointer;
      background:#3a3a44;
      color:#fff;
      font-size:14px;
    }
    button:hover{ filter:brightness(1.1); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    input{
      height:40px;
      border-radius:10px;
      border:none;
      outline:none;
      padding:0 12px;
      font-size:18px;
      width:min(420px, 70vw);
      max-width:100%;
    }
    @media (max-width: 520px){
      input{ font-size:16px; width:100%; }
    }

    .right{
      display:flex;
      gap:14px;
      font-size:14px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }

    .badge{ opacity:.95; display:flex; gap:8px; align-items:center; }
    .pill{
      display:inline-flex;
      align-items:center;
      padding:2px 10px;
      height:22px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color:#fff;
    }

    .progress{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }
    .dot{
      width:14px;
      height:14px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      position:relative;
    }
    .dot.done::after{
      content:"";
      position:absolute;
      inset:2px;
      border-radius:3px;
      background: rgba(255,255,255,.85);
      opacity:.75;
    }
    .dot.lv1{ background: color-mix(in srgb, var(--lv1) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv1) 40%, rgba(255,255,255,.18)); }
    .dot.lv2{ background: color-mix(in srgb, var(--lv2) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv2) 40%, rgba(255,255,255,.18)); }
    .dot.lv3{ background: color-mix(in srgb, var(--lv3) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv3) 40%, rgba(255,255,255,.18)); }
    .dot.lv4{ background: color-mix(in srgb, var(--lv4) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv4) 40%, rgba(255,255,255,.18)); }

    @media (max-width: 860px){
      .ui{ grid-template-columns: 1fr; }
      .right{ justify-content:flex-start; }
      .label{ white-space:normal; }
    }

    /* 入力ミス演出 */
    .shake { animation: shake .18s linear 0s 1; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-4px); }
      50%{ transform: translateX(4px); }
      75%{ transform: translateX(-3px); }
      100%{ transform: translateX(0); }
    }
    .wrong{ box-shadow: 0 0 0 2px rgba(255,107,107,.45); }

    /* 選択UI */
    #choiceWrap{
      display:none;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    #showAnswer{
      display:none;
      color: rgba(255,255,255,.9);
    }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c"></canvas>

  <div class="ui">
    <div class="left">
      <div class="controls">
        <button id="start">スタート</button>
        <button id="restart">リスタート</button>
      </div>

      <div class="label">ひらがなで入力してEnter：</div>
      <input id="inp"
             autocomplete="off"
             autocapitalize="off"
             spellcheck="false"
             inputmode="kana"
             placeholder="例：とうきょう"
             disabled />
      <div class="hint" id="status">読み込み中…（questions.csv）</div>
      <div class="hint">※落下なし（固定表示）。間違えたら「同じ/別」を選べる。</div>
    </div>

    <div class="right">
      <div class="badge">LV: <span class="pill" id="lvPill">-</span></div>
      <div class="badge">TIME: <span id="time">10.0</span>s</div>
      <div class="badge">LIFE: <span id="life">5</span></div>
      <div class="badge">正解: <span id="clears">0</span>/10</div>

      <div class="badge progress" title="進捗">
        <span class="hint">進捗</span>
        <div id="prog" class="progress"></div>
      </div>

      <div class="badge" id="choiceWrap">
        <span class="hint" id="choiceTitle">ミス：</span>
        <button id="retrySame">同じ問題</button>
        <button id="skipDiff">別の問題</button>
        <span class="hint" id="showAnswer"></span>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== 設定 =====
  const CSV_PATH = "./questions.csv";
  const TIME_LIMIT = 10.0;
  const TOTAL_CLEAR = 10;
  const LIFE_START = 5;

  // Lv固定内訳：1〜3が3問ずつ、4が1問
  const NEED = {1:3,2:3,3:3,4:1};

  // 表示位置（落下なし）
  const FIXED_Y_RATIO = 0.35; // 画面高さの35%あたりに固定
  const MIN_FIXED_Y = 120;

  const LV_COLOR = {
    1: getComputedStyle(document.documentElement).getPropertyValue('--lv1').trim(),
    2: getComputedStyle(document.documentElement).getPropertyValue('--lv2').trim(),
    3: getComputedStyle(document.documentElement).getPropertyValue('--lv3').trim(),
    4: getComputedStyle(document.documentElement).getPropertyValue('--lv4').trim(),
    default: getComputedStyle(document.documentElement).getPropertyValue('--lvD').trim()
  };

  // ===== Canvas =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);

  // ===== UI =====
  const startBtn = document.getElementById("start");
  const restartBtn = document.getElementById("restart");
  const inp = document.getElementById("inp");

  const uiStatus = document.getElementById("status");
  const uiTime = document.getElementById("time");
  const uiLife = document.getElementById("life");
  const uiClears = document.getElementById("clears");
  const uiLvPill = document.getElementById("lvPill");
  const progEl = document.getElementById("prog");

  const choiceWrap = document.getElementById("choiceWrap");
  const choiceTitle = document.getElementById("choiceTitle");
  const retrySameBtn = document.getElementById("retrySame");
  const skipDiffBtn = document.getElementById("skipDiff");
  const showAnswer = document.getElementById("showAnswer");

  // ===== 進捗（固定10マス）=====
  const progressDots = [];
  function buildProgressFixed() {
    progEl.innerHTML = "";
    progressDots.length = 0;

    const seq = [
      ...Array(3).fill(1),
      ...Array(3).fill(2),
      ...Array(3).fill(3),
      4
    ];

    for (let i = 0; i < seq.length; i++) {
      const lv = seq[i];
      const d = document.createElement("div");
      d.className = `dot lv${lv}`;
      d.title = `Q${i+1} (Lv${lv})`;
      progEl.appendChild(d);
      progressDots.push(d);
    }
    markProgressDone(0);
  }
  function markProgressDone(nDone) {
    for (let i = 0; i < progressDots.length; i++) {
      progressDots[i].classList.toggle("done", i < nDone);
    }
  }

  // ===== 音（外部ファイル不要）=====
  let audioCtx = null;
  function beep({freq=880, dur=0.07, type="triangle", vol=0.05} = {}) {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = vol;

      o.connect(g);
      g.connect(audioCtx.destination);

      const t = audioCtx.currentTime;
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      o.start(t);
      o.stop(t + dur);
    } catch (_) {}
  }

  // ===== CSV読み込み =====
  function parseCSV(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith("#"));
    if (!lines.length) return [];

    const header = lines[0].split(",").map(s => s.trim());
    const idx = (name) => header.indexOf(name);

    const iLevel = idx("level");
    const iKanji = idx("kanji");
    const iReading = idx("reading");
    if (iLevel < 0 || iKanji < 0 || iReading < 0) {
      throw new Error("CSVヘッダは level,kanji,reading が必要です");
    }

    const rows = [];
    for (let i=1; i<lines.length; i++) {
      const cols = lines[i].split(",").map(s => s.trim());
      const level = Number(cols[iLevel]);
      const kanji = cols[iKanji];
      const reading = cols[iReading];
      if (!level || !kanji || !reading) continue;
      rows.push({ level, kanji, reading });
    }
    return rows;
  }

  async function loadQuestions() {
    const res = await fetch(CSV_PATH, { cache: "no-store" });
    if (!res.ok) throw new Error(`CSV読み込み失敗: ${res.status}`);
    return parseCSV(await res.text());
  }

  // ===== ゲーム状態 =====
  let QUESTIONS = [];

  // レベルごとの「今回使う問題（3/3/3/1）」と「未正解プール」
  let remaining = {1:[],2:[],3:[],4:[]};
  let curLevel = 1;

  const state = {
    mode: "loading", // loading | ready | playing | gameover | clear
    current: null,
    startTime: 0,
    life: LIFE_START,
    clears: 0,

    // 間違い後の選択中
    waitingChoice: false,
    lastMissType: null // "timeout" | "wrong"
  };

  // 演出
  let flashAlpha = 0;
  let flashColor = "#ffffff";
  let maruAlpha = 0;

  function triggerCorrectFX(lv) {
    flashAlpha = 0.55;
    flashColor = LV_COLOR[lv] || "#ffffff";
    maruAlpha = 1.0;
  }

  function normalize(s){ return (s || "").trim(); }

  function shuffleInPlace(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function validateAndBuildPools() {
    const byLv = new Map([[1,[]],[2,[]],[3,[]],[4,[]]]);
    for (const q of QUESTIONS) {
      if (byLv.has(q.level)) byLv.get(q.level).push(q);
    }

    const missing = [];
    for (const lv of [1,2,3,4]) {
      if (byLv.get(lv).length < NEED[lv]) {
        missing.push(`Lv${lv}が${NEED[lv]}問必要（今${byLv.get(lv).length}問）`);
      }
    }
    if (missing.length) throw new Error("CSVの問題数が足りません: " + missing.join(" / "));

    // レベルごとに必要数だけピック（CSVに多くてもOK）
    const pick = {};
    for (const lv of [1,2,3,4]) {
      const arr = byLv.get(lv).slice();
      shuffleInPlace(arr);
      pick[lv] = arr.slice(0, NEED[lv]);
    }

    // 未正解プール（ここが空になるまで次Lvへ行かない）
    remaining = {
      1: pick[1].slice(),
      2: pick[2].slice(),
      3: pick[3].slice(),
      4: pick[4].slice()
    };
    curLevel = 1;

    buildProgressFixed();
  }

  function setLvPill(lv) {
    if (!lv) {
      uiLvPill.textContent = "-";
      uiLvPill.style.borderColor = "rgba(255,255,255,.15)";
      uiLvPill.style.background = "rgba(255,255,255,.06)";
      uiLvPill.style.color = "#fff";
      return;
    }
    const c = LV_COLOR[lv] || LV_COLOR.default;
    uiLvPill.textContent = `Lv${lv}`;
    uiLvPill.style.borderColor = c + "55";
    uiLvPill.style.background = c + "22";
    uiLvPill.style.color = c;
  }

  function setMode(m) {
    state.mode = m;

    if (m === "ready") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "スタート";
      uiStatus.textContent = "スタートを押して開始（ひらがなEnter / 制限10秒 / 10問正解でクリア）";
      setLvPill(null);
      uiTime.textContent = TIME_LIMIT.toFixed(1);
      hideChoice();
    }

    if (m === "playing") {
      inp.disabled = false;
      startBtn.disabled = true;
      inp.focus();
    }

    if (m === "clear") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "もう一回";
      uiStatus.textContent = "CLEAR！「もう一回」で再挑戦";
      hideChoice();
    }

    if (m === "gameover") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "もう一回";
      uiStatus.textContent = "GAME OVER…「もう一回」で再挑戦";
      hideChoice();
    }
  }

  function hideChoice() {
    state.waitingChoice = false;
    state.lastMissType = null;
    choiceWrap.style.display = "none";
    showAnswer.style.display = "none";
    showAnswer.textContent = "";
  }

  function resetGame() {
    state.life = LIFE_START;
    state.clears = 0;
    state.current = null;
    hideChoice();

    uiLife.textContent = state.life;
    uiClears.textContent = state.clears;
    markProgressDone(0);
    uiTime.textContent = TIME_LIMIT.toFixed(1);
    inp.value = "";
    inp.classList.remove("wrong","shake");

    validateAndBuildPools();
    setMode("ready");
  }

  function advanceLevelIfNeeded() {
    while (curLevel <= 4 && remaining[curLevel].length === 0) curLevel += 1;
  }

  // 同じLvの未正解から問題を引く（excludeSame=trueなら現在の問題以外を優先）
  function pickQuestionFromCurrentLevel(excludeSame) {
    const arr = remaining[curLevel];
    if (!arr.length) return null;

    if (!excludeSame || arr.length === 1 || !state.current) {
      const idx = Math.floor(Math.random() * arr.length);
      return { q: arr[idx], idx };
    }

    // 現在の問題と一致する要素を避ける
    const candidates = [];
    for (let i = 0; i < arr.length; i++) {
      const it = arr[i];
      if (it.kanji !== state.current.kanji || it.reading !== state.current.reading) {
        candidates.push({q: it, idx: i});
      }
    }
    if (!candidates.length) {
      const idx = Math.floor(Math.random() * arr.length);
      return { q: arr[idx], idx };
    }
    return candidates[Math.floor(Math.random() * candidates.length)];
  }

  function spawnNext({excludeSame=false} = {}) {
    if (state.clears >= TOTAL_CLEAR) {
      setMode("clear");
      return;
    }

    advanceLevelIfNeeded();
    if (curLevel > 4) {
      setMode("clear");
      return;
    }

    const picked = pickQuestionFromCurrentLevel(excludeSame);
    if (!picked) {
      setMode("clear");
      return;
    }

    const { q, idx } = picked;

    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    const fixedY = Math.max(MIN_FIXED_Y, H * FIXED_Y_RATIO);

    state.current = {
      level: q.level,
      kanji: q.kanji,
      reading: q.reading,
      x: W / 2,
      y: fixedY,
      timeLimit: TIME_LIMIT,
      _idxInRemaining: idx
    };

    state.startTime = performance.now();
    setLvPill(q.level);

    hideChoice();
    uiStatus.textContent = `Lv${q.level} / 残り ${TOTAL_CLEAR - state.clears}問`;
  }

  function startOrReplay() {
    if (state.mode === "ready") {
      setMode("playing");
      spawnNext();
      beep({freq: 660, dur: 0.05, type: "sine", vol: 0.03});
      return;
    }
    if (state.mode === "clear" || state.mode === "gameover") {
      resetGame();
      setMode("playing");
      spawnNext();
      beep({freq: 660, dur: 0.05, type: "sine", vol: 0.03});
    }
  }

  function correct() {
    // 正解したら未正解から削除
    if (state.current && typeof state.current._idxInRemaining === "number") {
      remaining[curLevel].splice(state.current._idxInRemaining, 1);
    }

    state.clears += 1;
    uiClears.textContent = state.clears;
    markProgressDone(state.clears);

    triggerCorrectFX(state.current?.level);
    beep({freq: 880, dur: 0.07, type: "triangle", vol: 0.05});

    if (state.clears >= TOTAL_CLEAR) {
      setMode("clear");
      return;
    }
    spawnNext();
  }

  function showChoice(type) {
    state.waitingChoice = true;
    state.lastMissType = type; // "timeout" | "wrong"

    choiceTitle.textContent = (type === "timeout") ? "時間切れ：" : "ミス：";
    choiceWrap.style.display = "flex";
    showAnswer.style.display = "none";
    showAnswer.textContent = "";

    uiStatus.textContent = (type === "timeout")
      ? "時間切れ！「同じ問題」か「別の問題」を選んでね"
      : "違う！「同じ問題」か「別の問題」を選んでね";
  }

  function wrongInputFX() {
    inp.classList.add("wrong","shake");
    if (navigator.vibrate) navigator.vibrate(15);
    setTimeout(() => inp.classList.remove("shake"), 220);
    setTimeout(() => inp.classList.remove("wrong"), 420);
    beep({freq: 300, dur: 0.04, type: "sine", vol: 0.03});
  }

  function timeoutMiss() {
    state.life -= 1;
    uiLife.textContent = state.life;

    beep({freq: 180, dur: 0.10, type: "sawtooth", vol: 0.04});
    if (navigator.vibrate) navigator.vibrate(40);

    if (state.life <= 0) {
      setMode("gameover");
      return;
    }

    showChoice("timeout");
  }

  // ===== 選択ボタン（ミス時）=====
  retrySameBtn.addEventListener("click", () => {
    if (state.mode !== "playing" || !state.current) return;

    // 同じ問題：タイマーだけリセットして再挑戦
    state.startTime = performance.now();
    hideChoice();
    inp.focus();
  });

  skipDiffBtn.addEventListener("click", () => {
    if (state.mode !== "playing" || !state.current) return;

    // 別の問題：答え表示してから同Lv内の別問題へ（未正解は残す）
    showAnswer.style.display = "inline";
    showAnswer.textContent = `答え：${state.current.reading}`;

    // 選択中はタイマー止めたまま
    setTimeout(() => {
      // 別問題を優先（同Lv内、可能なら現在以外）
      hideChoice();
      spawnNext({excludeSame:true});
      inp.focus();
    }, 900);
  });

  // ===== 入力 =====
  inp.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    e.preventDefault();

    if (state.mode !== "playing" || !state.current) return;
    if (state.waitingChoice) return; // 選択中は入力無効

    const typed = normalize(inp.value);
    inp.value = "";
    if (!typed) return;

    if (typed === state.current.reading) {
      correct();
    } else {
      // “ミスしても時間内ならOK”のルールを続けるなら
      // ここは本来「何もしない」でもいいけど、
      // 今回はユーザー要件で「ミス時に同じ/別を選べる」なので選択を出す
      wrongInputFX();
      showChoice("wrong");
    }
  });

  // Canvasタップでフォーカス
  canvas.addEventListener("pointerdown", () => {
    if (state.mode === "playing" && !state.waitingChoice) inp.focus();
  });

  startBtn.addEventListener("click", startOrReplay);
  restartBtn.addEventListener("click", () => {
    if (state.mode === "loading") return;
    resetGame();
  });

  // ===== 描画 =====
  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function drawOverlay(main, sub) {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.fillStyle = "rgba(0,0,0,.62)";
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "#fff";
    ctx.font = "bold 38px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText(main, W/2, H/2 - 18);

    if (sub) {
      ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillText(sub, W/2, H/2 + 22);
    }

    ctx.textAlign = "left";
  }

  function drawMaru() {
    if (maruAlpha <= 0) return;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.save();
    ctx.globalAlpha = maruAlpha;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(W/2, H/2 - 10, Math.min(W,H) * 0.10, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    maruAlpha *= 0.82;
    if (maruAlpha < 0.01) maruAlpha = 0;
  }

  function draw() {
    const now = performance.now();
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = "#0f0f12";
    ctx.fillRect(0, 0, W, H);

    // ガイド
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#ffffff";
    for (let i = 1; i <= 5; i++){
      const x = (W / 6) * i;
      ctx.fillRect(x - 1, 0, 2, H);
    }
    ctx.globalAlpha = 1;

    // 正解フラッシュ
    if (flashAlpha > 0.001) {
      ctx.globalAlpha = flashAlpha;
      ctx.fillStyle = flashColor;
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;
      flashAlpha *= 0.88;
    } else {
      flashAlpha = 0;
    }

    if (state.mode === "ready") {
      drawOverlay("スタートを押して開始", "ひらがなEnter / 制限10秒 / 10問正解でクリア");
      uiTime.textContent = TIME_LIMIT.toFixed(1);
      return;
    }
    if (state.mode === "gameover") {
      drawOverlay("GAME OVER", "「もう一回」or リスタート");
      uiTime.textContent = TIME_LIMIT.toFixed(1);
      return;
    }
    if (state.mode === "clear") {
      drawOverlay("CLEAR!", "10問正解。おつかれ！");
      uiTime.textContent = TIME_LIMIT.toFixed(1);
      return;
    }

    // プレイ中
    if (state.mode === "playing" && state.current) {
      // 選択中はタイマーを止める（表示は0.0固定）
      let remain = 0;
      if (!state.waitingChoice) {
        const elapsed = (now - state.startTime) / 1000;
        remain = Math.max(0, state.current.timeLimit - elapsed);
      }
      uiTime.textContent = remain.toFixed(1);

      // 時間切れ（選択中じゃない時だけ）
      if (!state.waitingChoice && remain <= 0) {
        timeoutMiss();
      }

      // 固定位置を常に再計算（画面回転などにも対応）
      const fixedY = Math.max(MIN_FIXED_Y, H * FIXED_Y_RATIO);
      state.current.x = W / 2;
      state.current.y = fixedY;

      const lv = state.current.level;
      const accent = LV_COLOR[lv] || LV_COLOR.default;

      const text = state.current.kanji;
      ctx.font = "32px system-ui, -apple-system, Segoe UI, sans-serif";
      const tw = ctx.measureText(text).width;
      const boxW = tw + 34;
      const boxH = 54;
      const x = state.current.x - boxW / 2;
      const y = state.current.y;

      // 影
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      roundRect(x, y + 3, boxW, boxH, 12);
      ctx.fill();
      ctx.globalAlpha = 1;

      // 本体
      ctx.fillStyle = "#3b3b46";
      roundRect(x, y, boxW, boxH, 12);
      ctx.fill();

      // アクセント
      ctx.fillStyle = accent + "cc";
      ctx.fillRect(x, y, boxW, 4);

      // 文字
      ctx.fillStyle = "#fff";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x + 17, y + boxH / 2);

      // タイムバー
      ctx.fillStyle = "#555";
      ctx.fillRect(x, y + boxH + 10, boxW, 7);
      ctx.fillStyle = accent;
      ctx.fillRect(x, y + boxH + 10, boxW * (remain / state.current.timeLimit), 7);

      // 正解「〇」
      drawMaru();
    }
  }

  function loop() {
    draw();
    requestAnimationFrame(loop);
  }

  // ===== 起動 =====
  (async () => {
    resize();
    try {
      uiStatus.textContent = "questions.csv を読み込み中…";
      QUESTIONS = await loadQuestions();
      if (!QUESTIONS.length) throw new Error("CSVに問題がありません");

      QUESTIONS = QUESTIONS.filter(q => [1,2,3,4].includes(q.level));

      validateAndBuildPools();

      uiLife.textContent = LIFE_START;
      uiClears.textContent = "0";
      setLvPill(null);
      uiTime.textContent = TIME_LIMIT.toFixed(1);

      resetGame();
      setMode("ready");
      uiStatus.textContent = "読み込み完了。スタートで開始";
      loop();
    } catch (err) {
      uiStatus.textContent = "読み込み失敗（questions.csv確認）： " + err.message;
      console.error(err);
      resetGame();
      setMode("ready");
      loop();
    }
  })();
})();
</script>
</body>
</html>
