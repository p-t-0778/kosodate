<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kanji GO-like (10Q Clear + Mobile)</title>
  <style>
    :root{
      --bg:#0f0f12;
      --panel:#222228;
      --card:#3b3b46;
      --text:#fff;
      --muted: rgba(255,255,255,.7);
      --muted2: rgba(255,255,255,.55);

      --lv1:#5ecbff;
      --lv2:#7bff91;
      --lv3:#ffd36b;
      --lv4:#ff6b6b;
      --lvD:#c9c9d2;
    }

    html, body { margin:0; height:100%; background:var(--bg); color:var(--text); }
    .wrap { height:100%; display:grid; grid-template-rows: 1fr auto; }
    canvas { width:100%; height:100%; display:block; touch-action: none; }

    .ui{
      background:var(--panel);
      padding:10px 12px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:12px;
      align-items:center;
    }

    .left{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      min-width:0;
    }

    .label{ font-size:14px; opacity:.9; white-space:nowrap; }
    .hint{ font-size:12px; color:var(--muted2); }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      height:40px;
      padding:0 12px;
      border-radius:10px;
      border:none;
      cursor:pointer;
      background:#3a3a44;
      color:#fff;
      font-size:14px;
    }
    button:hover{ filter:brightness(1.1); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    input{
      height:40px;
      border-radius:10px;
      border:none;
      outline:none;
      padding:0 12px;
      font-size:18px;
      width:min(420px, 70vw);
      max-width:100%;
    }

    /* iOSで拡大されにくいように16px以上確保 */
    @media (max-width: 520px){
      input{ font-size:16px; width:100%; }
    }

    .right{
      display:flex;
      gap:14px;
      font-size:14px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }

    .badge{ opacity:.95; display:flex; gap:8px; align-items:center; }
    .pill{
      display:inline-flex;
      align-items:center;
      padding:2px 10px;
      height:22px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color:#fff;
    }

    .progress{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }
    .dot{
      width:14px;
      height:14px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 0 rgba(255,255,255,0);
      position:relative;
    }
    .dot.done::after{
      content:"";
      position:absolute;
      inset:2px;
      border-radius:3px;
      background: rgba(255,255,255,.85);
      opacity:.75;
    }
    .dot.lv1{ background: color-mix(in srgb, var(--lv1) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv1) 40%, rgba(255,255,255,.18)); }
    .dot.lv2{ background: color-mix(in srgb, var(--lv2) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv2) 40%, rgba(255,255,255,.18)); }
    .dot.lv3{ background: color-mix(in srgb, var(--lv3) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv3) 40%, rgba(255,255,255,.18)); }
    .dot.lv4{ background: color-mix(in srgb, var(--lv4) 18%, rgba(255,255,255,.06)); border-color: color-mix(in srgb, var(--lv4) 40%, rgba(255,255,255,.18)); }

    /* スマホではUIを縦積み */
    @media (max-width: 860px){
      .ui{ grid-template-columns: 1fr; }
      .right{ justify-content:flex-start; }
      .label{ white-space:normal; }
    }

    /* 入力ミス演出（ミス扱いではない） */
    .shake { animation: shake .18s linear 0s 1; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-4px); }
      50%{ transform: translateX(4px); }
      75%{ transform: translateX(-3px); }
      100%{ transform: translateX(0); }
    }
    .wrong{
      box-shadow: 0 0 0 2px rgba(255,107,107,.45);
    }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c"></canvas>

  <div class="ui">
    <div class="left">
      <div class="controls">
        <button id="start">スタート</button>
        <button id="restart">リスタート</button>
      </div>

      <div class="label">ひらがなで入力してEnter：</div>
      <input id="inp"
             autocomplete="off"
             autocapitalize="off"
             spellcheck="false"
             inputmode="kana"
             placeholder="例：とうきょう"
             disabled />
      <div class="hint" id="status">読み込み中…（questions.csv）</div>
      <div class="hint">※スマホでも動くけど、遊びやすさはPC推奨（かな入力＋Enter）</div>
    </div>

    <div class="right">
      <div class="badge">LV: <span class="pill" id="lvPill">-</span></div>
      <div class="badge">TIME: <span id="time">10.0</span>s</div>
      <div class="badge">LIFE: <span id="life">5</span></div>
      <div class="badge">正解: <span id="clears">0</span>/10</div>
      <div class="badge progress" title="進捗">
        <span class="hint">進捗</span>
        <div id="prog" class="progress"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== 設定 =====
  const CSV_PATH = "./questions.csv";
  const TIME_LIMIT = 10.0;
  const TOTAL_CLEAR = 10;
  const LIFE_START = 5;

  // Lv固定（1〜4）内訳：1〜3が3問ずつ、4が1問
  const NEED = {1:3,2:3,3:3,4:1};

  const FALL_SPEED = 100;

  const LV_COLOR = {
    1: getComputedStyle(document.documentElement).getPropertyValue('--lv1').trim(),
    2: getComputedStyle(document.documentElement).getPropertyValue('--lv2').trim(),
    3: getComputedStyle(document.documentElement).getPropertyValue('--lv3').trim(),
    4: getComputedStyle(document.documentElement).getPropertyValue('--lv4').trim(),
    default: getComputedStyle(document.documentElement).getPropertyValue('--lvD').trim()
  };

  // ===== Canvas =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);

  // ===== UI =====
  const startBtn = document.getElementById("start");
  const restartBtn = document.getElementById("restart");
  const inp = document.getElementById("inp");

  const uiStatus = document.getElementById("status");
  const uiTime = document.getElementById("time");
  const uiLife = document.getElementById("life");
  const uiClears = document.getElementById("clears");
  const uiLvPill = document.getElementById("lvPill");
  const progEl = document.getElementById("prog");

  // ===== 進捗（10マス）=====
  const progressDots = [];
  function buildProgress(deck) {
    progEl.innerHTML = "";
    progressDots.length = 0;
    for (let i = 0; i < deck.length; i++) {
      const lv = deck[i].level;
      const d = document.createElement("div");
      d.className = `dot lv${lv}`;
      d.title = `Q${i+1} (Lv${lv})`;
      progEl.appendChild(d);
      progressDots.push(d);
    }
  }
  function markProgressDone(nDone) {
    for (let i = 0; i < progressDots.length; i++) {
      progressDots[i].classList.toggle("done", i < nDone);
    }
  }

  // ===== 音（外部ファイル不要）=====
  let audioCtx = null;
  function beep({freq=880, dur=0.07, type="triangle", vol=0.05} = {}) {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = vol;

      o.connect(g);
      g.connect(audioCtx.destination);

      const t = audioCtx.currentTime;
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      o.start(t);
      o.stop(t + dur);
    } catch (_) {}
  }

  // ===== CSV読み込み =====
  function parseCSV(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith("#"));
    if (!lines.length) return [];

    const header = lines[0].split(",").map(s => s.trim());
    const idx = (name) => header.indexOf(name);

    const iLevel = idx("level");
    const iKanji = idx("kanji");
    const iReading = idx("reading");
    if (iLevel < 0 || iKanji < 0 || iReading < 0) {
      throw new Error("CSVヘッダは level,kanji,reading が必要です");
    }

    const rows = [];
    for (let i=1; i<lines.length; i++) {
      const cols = lines[i].split(",").map(s => s.trim());
      const level = Number(cols[iLevel]);
      const kanji = cols[iKanji];
      const reading = cols[iReading];
      if (!level || !kanji || !reading) continue;
      rows.push({ level, kanji, reading });
    }
    return rows;
  }

  async function loadQuestions() {
    const res = await fetch(CSV_PATH, { cache: "no-store" });
    if (!res.ok) throw new Error(`CSV読み込み失敗: ${res.status}`);
    return parseCSV(await res.text());
  }

  // ===== ゲーム状態 =====
  let QUESTIONS = [];
  let deck = [];
  let deckIndex = 0;

  const state = {
    mode: "loading", // loading | ready | playing | gameover | clear
    current: null,
    startTime: 0,
    life: LIFE_START,
    clears: 0,
  };

  // 演出
  let flashAlpha = 0;
  let flashColor = "#ffffff";
  let maruAlpha = 0;  // 「〇」演出
  function triggerCorrectFX(lv) {
    flashAlpha = 0.55;
    flashColor = LV_COLOR[lv] || "#ffffff";
    maruAlpha = 1.0;
  }

  function normalize(s){ return (s || "").trim(); }

  function shuffleInPlace(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function validateAndBuildDeck() {
    const byLv = new Map([[1,[]],[2,[]],[3,[]],[4,[]]]);
    for (const q of QUESTIONS) {
      if (byLv.has(q.level)) byLv.get(q.level).push(q);
    }

    const missing = [];
    for (const lv of [1,2,3,4]) {
      if (byLv.get(lv).length < NEED[lv]) {
        missing.push(`Lv${lv}が${NEED[lv]}問必要（今${byLv.get(lv).length}問）`);
      }
    }
    if (missing.length) throw new Error("CSVの問題数が足りません: " + missing.join(" / "));

    // 各Lvから必要数だけ取る（CSVに多くてもOK）
    const picked = [];
    for (const lv of [1,2,3,4]) {
      const arr = byLv.get(lv).slice();
      shuffleInPlace(arr);
      picked.push(...arr.slice(0, NEED[lv]));
    }

    // Lv1→Lv2→Lv3→Lv4（同Lv内だけシャッフル）
    const lv1 = shuffleInPlace(picked.filter(q => q.level === 1));
    const lv2 = shuffleInPlace(picked.filter(q => q.level === 2));
    const lv3 = shuffleInPlace(picked.filter(q => q.level === 3));
    const lv4 = picked.filter(q => q.level === 4);

    deck = [...lv1, ...lv2, ...lv3, ...lv4];
    deckIndex = 0;

    buildProgress(deck);
    markProgressDone(0);
  }

  function setLvPill(lv) {
    if (!lv) {
      uiLvPill.textContent = "-";
      uiLvPill.style.borderColor = "rgba(255,255,255,.15)";
      uiLvPill.style.background = "rgba(255,255,255,.06)";
      uiLvPill.style.color = "#fff";
      return;
    }
    const c = LV_COLOR[lv] || LV_COLOR.default;
    uiLvPill.textContent = `Lv${lv}`;
    uiLvPill.style.borderColor = c + "55";
    uiLvPill.style.background = c + "22";
    uiLvPill.style.color = c;
  }

  function setMode(m) {
    state.mode = m;

    if (m === "ready") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "スタート";
      uiStatus.textContent = "スタートを押して開始（ひらがなでEnter / 制限10秒 / 10問でクリア）";
      setLvPill(null);
      uiTime.textContent = TIME_LIMIT.toFixed(1);
    }
    if (m === "playing") {
      inp.disabled = false;
      startBtn.disabled = true;
      inp.focus();
    }
    if (m === "clear") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "もう一回";
      uiStatus.textContent = "CLEAR！「もう一回」で再挑戦";
    }
    if (m === "gameover") {
      inp.disabled = true;
      startBtn.disabled = false;
      startBtn.textContent = "もう一回";
      uiStatus.textContent = "GAME OVER…「もう一回」で再挑戦";
    }
  }

  function resetGame() {
    state.life = LIFE_START;
    state.clears = 0;
    state.current = null;

    uiLife.textContent = state.life;
    uiClears.textContent = state.clears;
    uiTime.textContent = TIME_LIMIT.toFixed(1);
    inp.value = "";
    inp.classList.remove("wrong","shake");

    validateAndBuildDeck();
    setMode("ready");
  }

  function spawnNext() {
    if (state.clears >= TOTAL_CLEAR) {
      setMode("clear");
      return;
    }

    const q = deck[deckIndex];
    deckIndex += 1;

    const W = canvas.getBoundingClientRect().width;
    const lv = q.level;

    state.current = {
      level: lv,
      kanji: q.kanji,
      reading: q.reading,
      x: W / 2,
      y: 60,
      speed: FALL_SPEED,
      timeLimit: TIME_LIMIT
    };
    state.startTime = performance.now();
    setLvPill(lv);

    uiStatus.textContent = `残り ${TOTAL_CLEAR - state.clears}問（Lv${lv}）`;
  }

  function startOrReplay() {
    // ready -> start
    if (state.mode === "ready") {
      setMode("playing");
      spawnNext();
      beep({freq: 660, dur: 0.05, type: "sine", vol: 0.03});
      return;
    }

    // clear/gameover -> replay
    if (state.mode === "clear" || state.mode === "gameover") {
      resetGame();
      setMode("playing");
      spawnNext();
      beep({freq: 660, dur: 0.05, type: "sine", vol: 0.03});
    }
  }

  function timeoutMiss() {
    state.life -= 1;
    uiLife.textContent = state.life;

    // 低めの音
    beep({freq: 180, dur: 0.10, type: "sawtooth", vol: 0.04});

    if (navigator.vibrate) navigator.vibrate(40);

    if (state.life <= 0) {
      setMode("gameover");
      return;
    }
    spawnNext();
  }

  function correct() {
    state.clears += 1;
    uiClears.textContent = state.clears;
    markProgressDone(state.clears);

    // 正解演出
    triggerCorrectFX(state.current?.level);
    beep({freq: 880, dur: 0.07, type: "triangle", vol: 0.05});

    if (state.clears >= TOTAL_CLEAR) {
      setMode("clear");
      return;
    }
    spawnNext();
  }

  function wrongInputFX() {
    inp.classList.add("wrong","shake");
    if (navigator.vibrate) navigator.vibrate(15);
    // すぐ戻す
    setTimeout(() => {
      inp.classList.remove("shake");
    }, 220);
    setTimeout(() => {
      inp.classList.remove("wrong");
    }, 420);
    // 軽いSE（任意）
    beep({freq: 300, dur: 0.04, type: "sine", vol: 0.03});
  }

  // 入力：ひらがなのみ正解 / 誤入力はミス扱いしない（時間内ならOK）
  inp.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    e.preventDefault();

    if (state.mode !== "playing" || !state.current) return;

    const typed = normalize(inp.value);
    inp.value = "";
    if (!typed) return;

    if (typed === state.current.reading) {
      correct();
    } else {
      // “ミスしても時間内ならOK”だが、フィードバックだけは出す
      wrongInputFX();
    }
  });

  // クリックでフォーカス（スマホで入力しやすく）
  canvas.addEventListener("pointerdown", () => {
    if (state.mode === "playing") inp.focus();
  });

  startBtn.addEventListener("click", startOrReplay);
  restartBtn.addEventListener("click", () => {
    if (state.mode === "loading") return;
    resetGame();
  });

  // ===== 描画 =====
  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function drawOverlay(main, sub) {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.fillStyle = "rgba(0,0,0,.62)";
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "#fff";
    ctx.font = "bold 38px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText(main, W/2, H/2 - 18);

    if (sub) {
      ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillText(sub, W/2, H/2 + 22);
    }

    ctx.textAlign = "left";
  }

  function drawMaru() {
    if (maruAlpha <= 0) return;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.save();
    ctx.globalAlpha = maruAlpha;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(W/2, H/2 - 10, Math.min(W,H) * 0.10, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    maruAlpha *= 0.82; // 減衰
    if (maruAlpha < 0.01) maruAlpha = 0;
  }

  function draw() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = "#0f0f12";
    ctx.fillRect(0, 0, W, H);

    // ガイド
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#ffffff";
    for (let i = 1; i <= 5; i++){
      const x = (W / 6) * i;
      ctx.fillRect(x - 1, 0, 2, H);
    }
    ctx.globalAlpha = 1;

    // 正解フラッシュ
    if (flashAlpha > 0.001) {
      ctx.globalAlpha = flashAlpha;
      ctx.fillStyle = flashColor;
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;
      flashAlpha *= 0.88;
    } else {
      flashAlpha = 0;
    }

    // モード別
    if (state.mode === "ready") {
      drawOverlay("スタートを押して開始", "ひらがなEnter / 制限10秒 / 10問でクリア");
      uiTime.textContent = TIME_LIMIT.toFixed(1);
      return;
    }
    if (state.mode === "gameover") {
      drawOverlay("GAME OVER", "「もう一回」or リスタート");
      uiTime.textContent = TIME_LIMIT.toFixed(1);
      return;
    }
    if (state.mode === "clear") {
      drawOverlay("CLEAR!", "10問正解。おつかれ！");
      uiTime.textContent = TIME_LIMIT.toFixed(1);
      return;
    }

    // プレイ中
    if (state.mode === "playing" && state.current) {
      const elapsed = (performance.now() - state.startTime) / 1000;
      const remain = Math.max(0, state.current.timeLimit - elapsed);
      uiTime.textContent = remain.toFixed(1);

      if (remain <= 0) {
        timeoutMiss();
      }

      // 落下（見た目）
      if (state.mode === "playing" && state.current) {
        state.current.y += state.current.speed * (1/60);
      }

      const lv = state.current.level;
      const accent = LV_COLOR[lv] || LV_COLOR.default;

      const text = state.current.kanji;
      ctx.font = "32px system-ui, -apple-system, Segoe UI, sans-serif";
      const tw = ctx.measureText(text).width;
      const boxW = tw + 34;
      const boxH = 54;
      const x = state.current.x - boxW / 2;
      const y = state.current.y;

      // 影
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      roundRect(x, y + 3, boxW, boxH, 12);
      ctx.fill();
      ctx.globalAlpha = 1;

      // 本体
      ctx.fillStyle = "#3b3b46";
      roundRect(x, y, boxW, boxH, 12);
      ctx.fill();

      // アクセント
      ctx.fillStyle = accent + "cc";
      ctx.fillRect(x, y, boxW, 4);

      // 文字
      ctx.fillStyle = "#fff";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x + 17, y + boxH / 2);

      // タイムバー
      ctx.fillStyle = "#555";
      ctx.fillRect(x, y + boxH + 10, boxW, 7);
      ctx.fillStyle = accent;
      ctx.fillRect(x, y + boxH + 10, boxW * (remain / state.current.timeLimit), 7);

      // 正解「〇」
      drawMaru();
    }
  }

  function loop() {
    draw();
    requestAnimationFrame(loop);
  }

  // ===== 起動 =====
  (async () => {
    resize();
    try {
      uiStatus.textContent = "questions.csv を読み込み中…";
      QUESTIONS = await loadQuestions();
      if (!QUESTIONS.length) throw new Error("CSVに問題がありません");

      // Lv1〜4だけ
      QUESTIONS = QUESTIONS.filter(q => [1,2,3,4].includes(q.level));

      validateAndBuildDeck();

      uiLife.textContent = LIFE_START;
      uiClears.textContent = "0";
      setLvPill(null);
      uiTime.textContent = TIME_LIMIT.toFixed(1);

      resetGame();
      setMode("ready");
      uiStatus.textContent = "読み込み完了。スタートで開始";
      loop();
    } catch (err) {
      uiStatus.textContent = "読み込み失敗（questions.csv確認）： " + err.message;
      console.error(err);
      resetGame();
      setMode("ready");
      loop();
    }
  })();
})();
</script>
</body>
</html>

